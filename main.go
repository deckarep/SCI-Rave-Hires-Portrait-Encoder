package main

import (
	"bytes"
	"encoding/binary"
	"encoding/json"
	"fmt"
	"image"
	"image/color"
	"log"
	"os"
	"path"
	"path/filepath"

	_ "image/png"
)

//const (
//	BIN_FILE_NAME = "GRAHAM"
//	OG_PORTRAIT   = "GRAHAM.BIN"
//)

const (
	PAL_SIZE_BYTES = 768
	// Offsets
	OFFSET_NUM_BITMAPS = 0x7
	OFFSET_COLOR_PAL   = 0x11
)

type BGRColor struct {
	B byte
	G byte
	R byte
}

type RaveBitmap struct {
	Img     string `json:"img"`
	XOffset int    `json:"xOffset"`
	YOffset int    `json:"yOffset"`
}

type RaveJSON struct {
	RaveName      string       `json:"rave_name"`
	RaveExtension string       `json:"rave_extension"`
	Bitmaps       []RaveBitmap `json:"bitmaps"`
}

var bmpDimensions = make([]image.Point, 0)

var RAVE_FILE_HDR = []byte{0x57, 0x49, 0x4e, 0x70, 0x00, 0x9A, 0x00, 0x10, 0x00, 0x1C, 0x02, 0xB8, 0x00, 0x00, 0x03, 0x00, 0x00}
var ORIG_KQ6_RAVE_PALETTE = []byte{
	0x00, 0x00, 0x00, 0x00, 0x00, 0xBF, 0x00, 0xBF, 0x00, 0x00, 0xBF, 0xBF, 0xBF, 0x00, 0x00, 0xBF,
	0x00, 0xBF, 0xBF, 0xBF, 0x00, 0xC0, 0xC0, 0xC0, 0xC0, 0xDC, 0xC0, 0xF0, 0xC8, 0xA4, 0x00, 0x00,
	0x80, 0x00, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0x00, 0x80, 0x00, 0x80, 0x80, 0x80, 0x00,
	0x09, 0x09, 0x09, 0x12, 0x12, 0x12, 0x21, 0x21, 0x21, 0x32, 0x32, 0x32, 0x40, 0x40, 0x40, 0x52,
	0x52, 0x52, 0x9C, 0x9C, 0x9C, 0x63, 0x63, 0x63, 0x8A, 0x8A, 0x8A, 0x75, 0x75, 0x75, 0xFF, 0xFB,
	0xF0, 0x80, 0x80, 0x40, 0x00, 0xFF, 0x80, 0x00, 0x40, 0x40, 0xA4, 0xC8, 0xF0, 0x00, 0x80, 0xFF,
	0xA0, 0xA0, 0xA4, 0x00, 0x40, 0x80, 0xFF, 0x00, 0x80, 0x40, 0x00, 0x80, 0x80, 0x40, 0x00, 0xFA,
	0xFA, 0xFA, 0xF2, 0xF2, 0xF2, 0xE2, 0xE2, 0xE2, 0xD0, 0xD0, 0xD0, 0xC2, 0xC2, 0xC2, 0xB0, 0xB0,
	0xB0, 0x9F, 0x9F, 0x9F, 0x61, 0x61, 0x61, 0x82, 0x82, 0x82, 0x48, 0x48, 0x48, 0xAE, 0xAE, 0xAE,
	0x51, 0x51, 0x51, 0xA5, 0xA5, 0xA5, 0x5A, 0x5A, 0x5A, 0x93, 0x93, 0x93, 0x6C, 0x6C, 0x6C, 0x53,
	0x57, 0xEF, 0xDB, 0x9B, 0x77, 0x23, 0x57, 0xFF, 0x93, 0x4F, 0x3F, 0xB7, 0x6F, 0x57, 0x2F, 0x2F,
	0xC3, 0x3F, 0x43, 0xDF, 0x5F, 0x2B, 0x27, 0x7B, 0x3B, 0x33, 0xFB, 0xFB, 0xFB, 0x01, 0x01, 0x01,
	0x6F, 0x77, 0xF7, 0x23, 0x23, 0xAB, 0x17, 0x17, 0x93, 0xCB, 0xCB, 0xCB, 0x93, 0x9B, 0xFF, 0x77,
	0x93, 0xCB, 0x93, 0xA7, 0xEB, 0x2F, 0x77, 0xFF, 0x47, 0x3F, 0x73, 0xB7, 0xB7, 0xFF, 0x6F, 0x7F,
	0xD7, 0x47, 0x1B, 0x1B, 0xD3, 0xE3, 0xFF, 0xAB, 0xAB, 0xAB, 0x63, 0x63, 0x63, 0x6B, 0x67, 0xA3,
	0x87, 0x87, 0x87, 0x3B, 0x93, 0xFF, 0x57, 0xC7, 0xFF, 0xFF, 0xC7, 0xA3, 0x1F, 0x1F, 0x1F, 0x73,
	0xEF, 0xFF, 0xA7, 0xBF, 0xF3, 0x67, 0xDB, 0xFF, 0x2B, 0x2B, 0x00, 0x43, 0x43, 0x43, 0x83, 0xFF,
	0xFF, 0x4B, 0xAF, 0xFF, 0xBF, 0xCF, 0xFF, 0xDF, 0xB3, 0xFF, 0x00, 0x00, 0x00, 0xE7, 0xEB, 0x6B,
	0x6B, 0xD7, 0xBB, 0xFF, 0xFF, 0xFF, 0xFB, 0x6B, 0x00, 0x47, 0x47, 0x00, 0xFF, 0xFF, 0xFF, 0x01,
	0x01, 0x01, 0x63, 0x67, 0x0B, 0x7F, 0x83, 0x1B, 0x9B, 0x9F, 0x27, 0xB7, 0xBB, 0x3B, 0xCF, 0xD3,
	0x53, 0x00, 0x2F, 0x00, 0x00, 0x43, 0x00, 0x00, 0x5B, 0x1B, 0x0F, 0x73, 0x37, 0x27, 0x93, 0x57,
	0x3B, 0xAB, 0x7B, 0x53, 0xBF, 0x9B, 0xA7, 0x13, 0x5F, 0xC7, 0x4B, 0x8F, 0xCF, 0x5B, 0x9B, 0xD3,
	0x67, 0xC3, 0xE3, 0x7B, 0xE3, 0xEB, 0x8F, 0xC7, 0xBF, 0x73, 0xFF, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x01, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F,
	0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F,
	0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F,
	0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F,
	0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F,
	0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F,
	0x7F, 0x7F, 0xF0, 0xFB, 0xFF, 0xA4, 0xA0, 0xA0, 0x80, 0x80, 0x80, 0x00, 0x00, 0xFF, 0x00, 0xFF,
	0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF,
}

func main() {
	if len(os.Args) != 2 {
		log.Fatal("You must run referencing a file like: go run main.go <file.JSON>")
	}

	// 0. Load JSON RAVE definition file
	doc := loadRAVEFile(os.Args[1])

	// 1. Setup BIN header which includes the canonical header + palette data.
	raveHdr := make([]byte, len(RAVE_FILE_HDR)+len(ORIG_KQ6_RAVE_PALETTE))
	copy(raveHdr, RAVE_FILE_HDR)

	// 2. For however many images we're encoding update the NUM_BITMAPS in the header.
	numBitmaps := uint16(len(doc.Bitmaps))
	binary.LittleEndian.PutUint16(raveHdr[OFFSET_NUM_BITMAPS:], numBitmaps)

	// 3. Copy over palette
	copy(raveHdr[OFFSET_COLOR_PAL:], ORIG_KQ6_RAVE_PALETTE)

	// 3.a Pack in the header + palette.
	var hdr_palette_bitmaps_offsets []byte
	hdr_palette_bitmaps_offsets = append(hdr_palette_bitmaps_offsets, raveHdr...)

	// Here's the data we're encoding: new bitmaps + new offset tables.
	// 4. Iterate over bitmaps and place each bitmap header, and bitmap image.
	hdr_palette_bitmaps_offsets = append(hdr_palette_bitmaps_offsets, packBitmaps(doc, doc.Bitmaps)...)

	// 5. Write offset tables
	hdr_palette_bitmaps_offsets = append(hdr_palette_bitmaps_offsets, packBitmapOffsetTables(doc.Bitmaps)...)

	// 6. Concatenate everything with lip-sync data of original file.
	lipSyncBytes := grabLipSyncBlock(doc)
	hdr_palette_bitmaps_offsets = append(hdr_palette_bitmaps_offsets, lipSyncBytes...)

	// 5. Lastly, generate new .BIN file
	err := os.WriteFile(fmt.Sprintf(doc.RaveName+"_GEN"+doc.RaveExtension), hdr_palette_bitmaps_offsets, 0600)
	if err != nil {
		log.Fatal("failed to write final output file with err: ", err.Error())
	}
}

func packBitmaps(doc *RaveJSON, bmps []RaveBitmap) []byte {
	var buf bytes.Buffer

	const (
		OFF_BMP_HDR_WIDTH          = 0x2
		OFF_BMP_HDR_HEIGHT         = 0x4
		OFF_BMP_HDR_BYTES_PER_LINE = 0x6
	)

	for _, bmp := range bmps {
		// 0. Process bitmap
		bmpFileName := doc.RaveName + bmp.Img
		w, h, bmpBytes := processBitmap(doc, bmpFileName)

		// Note: After losing a few hours of trying to make my output match the original image I don't think it will work anyway.
		// 1. I'm loading Graham to do: load .png -> palette snap .png -> color indexed back into file
		// 2. When I extracted, I accounted for bytesPerLine and when I rebuild I don't bother with bytesPerLine I just use 0.
		// 3. Outcome: ScummVM should just do the right thing if I encoded my images with no padding (padding = 0) but this
		//    implies the binaries will never match. Oh well as that's not my goal anyway it's to have new character portraits.

		// I've confirmed that I can safely re-encode with no padding. It's completely unecessary even though the
		// original .BIN files utilized it.
		bytesPerLine := w

		// 1. Do the 14-byte bitmap header, for every bitmap needed.
		bmpHdr := make([]byte, 14)
		binary.LittleEndian.PutUint16(bmpHdr[OFF_BMP_HDR_WIDTH:], uint16(w))
		binary.LittleEndian.PutUint16(bmpHdr[OFF_BMP_HDR_HEIGHT:], uint16(h))
		binary.LittleEndian.PutUint16(bmpHdr[OFF_BMP_HDR_BYTES_PER_LINE:], uint16(bytesPerLine))
		buf.Write(bmpHdr)

		// 2. Pack the bitmap itself.
		buf.Write(bmpBytes)
	}

	return buf.Bytes()
}

func processBitmap(doc *RaveJSON, pngFile string) (int, int, []byte) {
	// 1. load in the original matching .bin file and harvest the EXACT palette!
	absoluteIndex := make([]BGRColor, 0)
	dedupedPal := make(map[BGRColor]byte)
	fileBytes, err := os.ReadFile(path.Join("../../Originals/", doc.RaveName+doc.RaveExtension))
	if err != nil {
		log.Fatal("failed to read the original matching .BIN file with err: ", err)
	}

	// 2. Rebuild the color index table.
	var lookupIdx byte = 0
	for i := OFFSET_COLOR_PAL; i < PAL_SIZE_BYTES; i += 3 {
		blue := fileBytes[i]
		green := fileBytes[i+1]
		red := fileBytes[i+2]

		in := BGRColor{R: red, G: green, B: blue}
		absoluteIndex = append(absoluteIndex, in)
		dedupedPal[in] = lookupIdx
		lookupIdx += 1
	}

	var findIdxByColor = func(clr BGRColor) byte {
		for i, c := range absoluteIndex {
			if clr == c {
				return byte(i)
			}
		}

		log.Fatal("couldn't find an index for this color - this should never happen: ", clr)
		return 0
	}

	// create a Go palette from an original file.
	var pal color.Palette = make([]color.Color, 0)
	for c, _ := range dedupedPal {
		newCol := color.RGBA{
			R: c.R,
			G: c.G,
			B: c.B,
			A: 255,
		}
		pal = append(pal, newCol)
	}

	// Open any photo and snap to the palette above.
	reader, err := os.Open(pngFile)
	if err != nil {
		log.Fatal(err)
	}
	defer reader.Close()

	m, _, err := image.Decode(reader)
	if err != nil {
		log.Fatal(err)
	}

	// 1. Grab color set.
	colorIdxedImg := make([]byte, 0)
	bounds := m.Bounds()
	bmpWidth := bounds.Max.X
	bmpHeight := bounds.Max.Y
	for y := bounds.Min.Y; y < bounds.Max.Y; y++ {
		for x := bounds.Min.X; x < bounds.Max.X; x++ {
			// For every pixel map pixel color to a color index of the palette in question.
			// The outcome is bitmaps are not stored by: RGB but a single color index byte.
			c := m.At(x, y)
			snappedColor := pal.Convert(c)
			nr, ng, nb, _ := snappedColor.RGBA()
			bgrStyleColor := BGRColor{
				R: byte(nr),
				G: byte(ng),
				B: byte(nb),
			}
			colorIdx := findIdxByColor(bgrStyleColor)
			colorIdxedImg = append(colorIdxedImg, colorIdx)
		}
	}

	bmpBytes := make([]byte, len(colorIdxedImg))
	for i := 0; i < len(colorIdxedImg); i++ {
		bmpBytes[i] = colorIdxedImg[i]
	}

	// Store bitmap (w, h) data as we'll need later for generating offset tables.
	bmpDimensions = append(bmpDimensions, image.Pt(bmpWidth, bmpHeight)) //dim{w: bmpWidth, h: bmpHeight})

	return bmpWidth, bmpHeight, bmpBytes
}

func packBitmapOffsetTables(bmps []RaveBitmap) []byte {
	const (
		OFF_DISPLACE_X = 0
		OFF_DISPLACE_Y = 2
		OFF_BMP_WIDTH  = 4
		OFF_BMP_HEIGHT = 6
		// The remaining offset table data is just random or null-byte data never read.
	)

	var buf bytes.Buffer

	// 1. first write offset table size as uint32LE
	// NOTE: This wants the size in bytes which is why it's storing it in a uin32.
	offsetTableSize := make([]byte, 4)
	binary.LittleEndian.PutUint32(offsetTableSize, uint32((len(bmps)+1)*14))
	buf.Write(offsetTableSize)

	// Write a dummy table of zeroes...although useless the original .BIN offset tables also had a single dummy entry.
	buf.Write(bytes.Repeat([]byte{0}, 14))

	// 2. Next pack all offsets but first one is dummy table.
	for i, bmp := range bmps {
		table := make([]byte, 14)
		binary.LittleEndian.PutUint16(table[OFF_DISPLACE_X:], uint16(bmp.XOffset))
		binary.LittleEndian.PutUint16(table[OFF_DISPLACE_Y:], uint16(bmp.YOffset))

		w := bmpDimensions[i].X
		h := bmpDimensions[i].Y
		binary.LittleEndian.PutUint16(table[OFF_BMP_WIDTH:], uint16(w))
		binary.LittleEndian.PutUint16(table[OFF_BMP_HEIGHT:], uint16(h))

		buf.Write(table)
	}

	return buf.Bytes()
}

func grabLipSyncBlock(doc *RaveJSON) []byte {
	b, err := os.ReadFile(path.Join("../../Originals/", doc.RaveName+doc.RaveExtension))
	if err != nil {
		log.Fatal("failed to read original .BIN file with err: ", err)
	}

	const (
		OFF_HDR_NUM_BITMAPS  = 0x7
		OFF_STARTING_BMP_HDR = 0x311

		// Relative offsets
		OFF_BMP_HDR_HEIGHT         = 0x4
		OFF_BMP_HDR_BYTES_PER_LINE = 0x6
	)

	numBitmaps := binary.LittleEndian.Uint16(b[OFF_HDR_NUM_BITMAPS:])
	nextHdrOffset := OFF_STARTING_BMP_HDR

	for i := 0; i < int(numBitmaps); i++ {
		hdrSlice := b[nextHdrOffset : nextHdrOffset+14]

		height := binary.LittleEndian.Uint16(hdrSlice[OFF_BMP_HDR_HEIGHT:])
		bytesPerLine := binary.LittleEndian.Uint16(hdrSlice[OFF_BMP_HDR_BYTES_PER_LINE:])
		nextHdrOffset += 14 + (int(height) * int(bytesPerLine))
	}

	// Next we need to skip original file offset tables (we don't use this, we use ours) to get to the lip-sync data.
	offsetDisplacementTables := nextHdrOffset
	offsetDisplacementTableSizeBytes := binary.LittleEndian.Uint32(b[offsetDisplacementTables:])

	// Lipsync data starts at offset for displacement tables + 4 (uint32 read above) + offsetDisplacementTableSizeBytes
	offsetLipSyncStart := offsetDisplacementTables + 4 + int(offsetDisplacementTableSizeBytes)
	return b[offsetLipSyncStart:]
}

func loadRAVEFile(jsonFile string) *RaveJSON {
	b, err := os.ReadFile(jsonFile)
	if err != nil {
		log.Fatal("failed to load json with err: ", err)
	}

	err = os.Chdir(filepath.Dir(jsonFile))
	if err != nil {
		log.Fatal("failed to change into working directory of: ", jsonFile)
	}

	var obj RaveJSON
	err = json.Unmarshal(b, &obj)
	if err != nil {
		log.Fatal("failed to unmarshal json with err: ", err)
	}

	return &obj
}
